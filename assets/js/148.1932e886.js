(window.webpackJsonp=window.webpackJsonp||[]).push([[148],{517:function(r,t,a){"use strict";a.r(t);var e=a(46),v=Object(e.a)({},(function(){var r=this,t=r.$createElement,a=r._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[a("h1",{attrs:{id:"架构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#架构"}},[r._v("#")]),r._v(" 架构")]),r._v(" "),a("h2",{attrs:{id:"传统消息队列应用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#传统消息队列应用场景"}},[r._v("#")]),r._v(" 传统消息队列应用场景")]),r._v(" "),a("p",[a("img",{attrs:{src:"https://gitee.com/Iekrwh/md-images/raw/master/images/image-20211113141349708.png",alt:"image-20211113141349708"}})]),r._v(" "),a("h2",{attrs:{id:"消息队列两种模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#消息队列两种模式"}},[r._v("#")]),r._v(" 消息队列两种模式")]),r._v(" "),a("ol",[a("li",[a("p",[a("strong",[r._v("点对点模式")]),r._v("（一对一，消费者主动拉取数据，消息收到后消息清除）")]),r._v(" "),a("p",[r._v("消息生产者生产消息发送到Queue中，然后消息消费者从Queue中取出并且消费消息。")]),r._v(" "),a("p",[r._v("消息被消费以后，queue中不再有存储，所以消息消费者不可能消费到已经被消费的消息。Queue支持存在多个消费者，但是对一个消息而言，只会有一个消费者可以消费。")]),r._v(" "),a("p",[a("img",{attrs:{src:"https://gitee.com/Iekrwh/md-images/raw/master/images/image-20211113141646214.png",alt:"image-20211113141646214"}})])]),r._v(" "),a("li",[a("p",[a("strong",[r._v("发布/订阅模式")]),r._v("（一对多，消费者消费数据之后不会清除消息）")]),r._v(" "),a("p",[r._v("消息生产者（发布）将消息发布到topic中，同时有多个消息消费者（订阅）消费该消息。和点对点方式不同，发布到topic的消息会被所有订阅者消费。")]),r._v(" "),a("p",[a("img",{attrs:{src:"C:/Users/Iekr/AppData/Roaming/Typora/typora-user-images/image-20211113141659252.png",alt:"image-20211113141659252"}})])])]),r._v(" "),a("h2",{attrs:{id:"基础架构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基础架构"}},[r._v("#")]),r._v(" 基础架构")]),r._v(" "),a("p",[r._v("Kafka是一个分布式的基于发布/订阅模式的**消息队列，**主要应用于大数据实时处理领域。")]),r._v(" "),a("p",[a("img",{attrs:{src:"https://gitee.com/Iekrwh/md-images/raw/master/images/image-20211113163202182.png",alt:"image-20211113163202182"}})]),r._v(" "),a("ol",[a("li",[r._v("Producer ："),a("strong",[r._v("消息生产者")]),r._v("，就是向kafka broker发消息的客户端；")]),r._v(" "),a("li",[r._v("Consumer ："),a("strong",[r._v("消息消费者")]),r._v("，向kafka broker取消息的客户端；")]),r._v(" "),a("li",[r._v("Consumer Group （CG）："),a("strong",[r._v("消费者组")]),r._v("，由多个consumer组成。消费者组内每个消费者负责消费不同分区的数据，一个分区只能由一个消费者消费；"),a("strong",[r._v("消费者组之间互不影响。所有的消费者都属于某个消费者组，即消费者组是逻辑上的一个订阅者")]),r._v("。")]),r._v(" "),a("li",[r._v("Broker ："),a("strong",[r._v("一台kafka服务器就是一个broker")]),r._v("。一个集群由"),a("strong",[r._v("多个broker组成")]),r._v("。一个broker可以容纳多个"),a("strong",[r._v("topic")]),r._v("。")]),r._v(" "),a("li",[r._v("Topic ：可以理解为一个"),a("strong",[r._v("队列")]),r._v("，生产者和消费者面向的都是一个topic；")]),r._v(" "),a("li",[r._v("Partition：为了实现扩展性，一个非常大的topic可以分布到多个broker（即服务器）上，一个topic可以分为多个partition，每个partition是一个"),a("strong",[r._v("有序的队列")]),r._v("；")]),r._v(" "),a("li",[r._v("Replica："),a("strong",[r._v("副本")]),r._v("，为保证集群中的某个节点发生故障时，该节点上的partition"),a("strong",[r._v("数据不丢失")]),r._v("，且kafka仍然能够继续工作，kafka提供了副本机制，一个topic的每个分区都有若干个副本，"),a("strong",[r._v("一个leader和若干个follower")]),r._v("。")]),r._v(" "),a("li",[r._v("leader：每个分区多个"),a("strong",[r._v("副本的“主”")]),r._v("，"),a("strong",[r._v("生产者发送数据的对象")]),r._v("，以及消费者消费数据的对象都是leader。")]),r._v(" "),a("li",[r._v("follower：每个分区多个"),a("strong",[r._v("副本中的“从")]),r._v("”，实时从leader中同步数据，"),a("strong",[r._v("保持和leader数据的同步")]),r._v("。"),a("strong",[r._v("leader发生故障时，某个follower会成为新的leader。")])])])])}),[],!1,null,null,null);t.default=v.exports}}]);