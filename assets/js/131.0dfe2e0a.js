(window.webpackJsonp=window.webpackJsonp||[]).push([[131],{503:function(v,_,t){"use strict";t.r(_);var a=t(46),s=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"继承"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#继承"}},[v._v("#")]),v._v(" 继承")]),v._v(" "),t("p",[v._v("继承是面向对象三大特征之一。可以使得子类具有父类的属性和方法，还可以在子类中重新定义，追加属性和方法")]),v._v(" "),t("p",[v._v("格式：pubilc class 子类名 extends 父类名{}")]),v._v(" "),t("p",[v._v("如：public class Zi extends Fu{}")]),v._v(" "),t("p",[v._v("Fu：是父类，又称为基类，超类")]),v._v(" "),t("p",[v._v("Zi：是子类，又称为派生类")]),v._v(" "),t("h2",{attrs:{id:"继承的好处与弊端"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#继承的好处与弊端"}},[v._v("#")]),v._v(" 继承的好处与弊端")]),v._v(" "),t("p",[v._v("好处")]),v._v(" "),t("p",[v._v("提高了代码的复用性(多个类相同的成员或者方法可以放到同一个类中)")]),v._v(" "),t("p",[v._v("提高了代码的维护性（如果方法的代码需要修改，修改一处即可）")]),v._v(" "),t("p",[v._v("弊端")]),v._v(" "),t("p",[v._v("继承让类与类之间产生了关系，类的耦合性增强了，当父类发生变化时子类也不得不跟着变化，削弱了子类的独立性")]),v._v(" "),t("p",[v._v("什么时候使用继承？")]),v._v(" "),t("p",[v._v("继承体现的关系：is a")]),v._v(" "),t("p",[v._v("假设法：我有两个类A和B，如果他们满足A是B的一种，或者B是A的一种，就说明他们存在继承关系，这个时候就可以考虑使用继承，否则不能滥用继承，因为不确定父类什么时候改变，而子类是否需要这些继承的属性或方法。")]),v._v(" "),t("p",[v._v("相对于父类必须是子类的真子集")]),v._v(" "),t("h2",{attrs:{id:"继承中变量的访问特点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#继承中变量的访问特点"}},[v._v("#")]),v._v(" 继承中变量的访问特点")]),v._v(" "),t("p",[v._v("在子类方法中访问一个变量的访问顺序是")]),v._v(" "),t("ol",[t("li",[v._v("子类局部范围找")]),v._v(" "),t("li",[v._v("子类成员范围找")]),v._v(" "),t("li",[v._v("父类成员范围找")]),v._v(" "),t("li",[v._v("如果都没有则报错（不考虑父类的父类）")])]),v._v(" "),t("h2",{attrs:{id:"super"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#super"}},[v._v("#")]),v._v(" super")]),v._v(" "),t("p",[v._v("super关键字用法与this关键字的用法相似")]),v._v(" "),t("p",[v._v("this:代表本类对象的引用")]),v._v(" "),t("p",[v._v("super:代表父类存储空间的标识（也可以理解为父类对象引用）")]),v._v(" "),t("h2",{attrs:{id:"继承中构造方法的访问特点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#继承中构造方法的访问特点"}},[v._v("#")]),v._v(" 继承中构造方法的访问特点")]),v._v(" "),t("p",[v._v("子类中所有的构造方法默认都会访问父类中无参的构造方法")]),v._v(" "),t("p",[v._v("因为子类会继承父类中的数据，可能还会使用父类的数据。所以在子类初始化前，一定要先完成父类数据的初始化")]),v._v(" "),t("p",[v._v("每一个子类构造方法的第一条语句默认都是：super()，如果父类中并没有无参构造方法则报错")]),v._v(" "),t("p",[t("strong",[v._v("super()调用的是父类的构造方法")])]),v._v(" "),t("p",[v._v("如果父类中没有无参构造方法")]),v._v(" "),t("p",[v._v("只有带参构造方法则通过使用super关键字去调用父类中的代词构造方法")]),v._v(" "),t("p",[v._v("建议在父类中提供一个无参构造方法")]),v._v(" "),t("h2",{attrs:{id:"继承中成员方法的访问特点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#继承中成员方法的访问特点"}},[v._v("#")]),v._v(" 继承中成员方法的访问特点")]),v._v(" "),t("p",[v._v("通过子类对象访问一个方法顺序")]),v._v(" "),t("ol",[t("li",[v._v("子类成员范围找")]),v._v(" "),t("li",[v._v("父类成员范围找")]),v._v(" "),t("li",[v._v("如果都没有则报错（不考虑父类的父类j）")])]),v._v(" "),t("h2",{attrs:{id:"方法重写"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#方法重写"}},[v._v("#")]),v._v(" 方法重写")]),v._v(" "),t("h3",{attrs:{id:"概述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[v._v("#")]),v._v(" 概述")]),v._v(" "),t("p",[v._v("子类中出现了和父类一模一样的方法声明")]),v._v(" "),t("p",[v._v("并在子类重写方法可以在方法中使用super关键字调用父类的方法")]),v._v(" "),t("h3",{attrs:{id:"校验是否是方法重写"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#校验是否是方法重写"}},[v._v("#")]),v._v(" 校验是否是方法重写")]),v._v(" "),t("p",[v._v("在重写构造方法上方加上@ovrride  如果报错则此子类构造方法不是重写")]),v._v(" "),t("h3",{attrs:{id:"注意事项"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#注意事项"}},[v._v("#")]),v._v(" 注意事项")]),v._v(" "),t("ol",[t("li",[t("p",[v._v("父类中的私有方法是不允许重写的")])]),v._v(" "),t("li",[t("p",[v._v("声明方法父类与子类必须相同  如不加public关键字   系统默认也是有声明关键字,但不用public权限高")]),v._v(" "),t("p",[v._v("(public > 默认 >  private)")])])]),v._v(" "),t("h2",{attrs:{id:"继承注意事项"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#继承注意事项"}},[v._v("#")]),v._v(" 继承注意事项")]),v._v(" "),t("ol",[t("li",[v._v("一个子类不能继承多个父类 只有继承一个父类")]),v._v(" "),t("li",[v._v("可以使用嵌套子类继承父类,父类继承父类的父类(多层继承)")])])])}),[],!1,null,null,null);_.default=s.exports}}]);